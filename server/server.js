// server.js - Point d'entr√©e du serveur Express avec authentification admin
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { initializeApp } = require('firebase/app');
const { getStorage, ref, uploadBytes, getDownloadURL } = require('firebase/storage');
require('dotenv').config();

// Initialisation de l'application Express
const app = express();
const PORT = process.env.PORT || 5000;
const QRCode = require('qrcode');
const fs = require('fs');  // ‚úÖ Import synchrone standard
const fsPromises = require('fs').promises;  // ‚úÖ Import pour les op√©rations async
const archiver = require('archiver');
const { createReadStream } = require('fs');

// Middlewares de s√©curit√©
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Configuration Helmet pour la s√©curit√© des headers HTTP
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:", "blob:"],
      // Interdire l'inline; les scripts sont maintenant externes
      scriptSrc: ["'self'"],
      objectSrc: ["'none'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
    }
  },
  crossOriginEmbedderPolicy: false // N√©cessaire pour Firebase
}));

// Configuration CORS s√©curis√©e avec whitelist de domaines
const allowedOrigins = [
  'http://localhost:3000', // D√©veloppement local
  'https://invitation-anniversaire.onrender.com', // Production
  process.env.FRONTEND_URL, // URL frontend depuis les variables d'environnement
].filter(Boolean); // Filtrer les valeurs undefined

app.use(cors({
  origin: function (origin, callback) {
    // Autoriser les requ√™tes sans origine (applications mobiles, Postman, etc.)
    if (!origin) return callback(null, true);
    
    // V√©rifier si l'origine est dans la whitelist
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.warn(`CORS: Origin non autoris√©e: ${origin}`);
      callback(new Error('Non autoris√© par la politique CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true, // N√©cessaire pour les cookies JWT
  optionsSuccessStatus: 200 // Support des anciens navigateurs
}));

// Rate limiting global
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limite de 100 requ√™tes par IP
  message: {
    success: false,
    message: 'Trop de requ√™tes depuis cette IP, veuillez r√©essayer plus tard.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

app.use(globalLimiter);

// Middleware de sanitisation
const { sanitizeMiddleware } = require('./middleware/sanitization');
app.use(sanitizeMiddleware());

// Middleware de base
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(require('cookie-parser')());

// Logs pour le d√©bogage
console.log('D√©marrage du serveur...');
console.log('Variables d\'environnement charg√©es:', process.env.ADMIN_PASSWORD_HASH ? 'Oui (ADMIN_PASSWORD_HASH)' : 'Non (ADMIN_PASSWORD_HASH manquant)');

// V√©rification des variables d'environnement critiques
const requiredEnvVars = ['MONGODB_URI', 'ADMIN_PASSWORD_HASH'];
const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);

if (missingEnvVars.length > 0) {
  console.error('üö® Variables d\'environnement manquantes:', missingEnvVars.join(', '));
  console.error('‚ö†Ô∏è  V√©rifiez votre fichier .env ou vos variables d\'environnement');
  
  if (process.env.NODE_ENV === 'production') {
    console.error('‚ùå Arr√™t du serveur en production');
    process.exit(1);
  } else {
    console.warn('‚ö†Ô∏è  Mode d√©veloppement : continuez avec des valeurs par d√©faut');
  }
}

// Configuration de la connexion MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/birthday-invitation', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('MongoDB connect√©'))
.catch(err => console.error('Erreur de connexion √† MongoDB:', err));

// Configuration de Firebase (pour le stockage des photos)
let storage = null;

if (process.env.FIREBASE_API_KEY && process.env.FIREBASE_STORAGE_BUCKET) {
  const firebaseConfig = {
    apiKey: process.env.FIREBASE_API_KEY,
    authDomain: process.env.FIREBASE_AUTH_DOMAIN,
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
    appId: process.env.FIREBASE_APP_ID
  };

  const firebaseApp = initializeApp(firebaseConfig);
  storage = getStorage(firebaseApp);
  console.log('‚úÖ Firebase configur√© avec succ√®s');
} else {
  console.warn('‚ö†Ô∏è  Firebase non configur√© - fonctionnalit√©s de photos d√©sactiv√©es');
}

// Configuration de Multer pour le t√©l√©chargement des fichiers
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024 // Limite √† 10MB
  },
  fileFilter: (req, file, cb) => {
    const filetypes = /jpeg|jpg|png|gif/;
    const mimetype = filetypes.test(file.mimetype);
    const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
    
    if (mimetype && extname) {
      return cb(null, true);
    }
    cb(new Error('Format de fichier non support√©. Utilisez JPG, PNG ou GIF.'));
  }
});

// D√©finition des mod√®les MongoDB
const rsvpSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true },
  attending: { type: String, required: true },
  guests: { type: Number, default: 0 },
  message: { type: String },
  needsAccommodation: { type: Boolean, default: false },
  qrCodeUrl: { type: String },
  uniqueCode: { type: String },
  hasCheckedIn: { type: Boolean, default: false },
  checkInTime: { type: Date },
  createdAt: { type: Date, default: Date.now }
});

const photoSchema = new mongoose.Schema({
  url: { type: String, required: true },
  thumbnailUrl: { type: String },
  uploadedBy: { type: String, required: true },
  createdAt: { type: Date, default: Date.now }
});

const RSVP = mongoose.model('RSVP', rsvpSchema);
const Photo = mongoose.model('Photo', photoSchema);

// Middleware d'authentification admin pour les routes prot√©g√©es
const verifyAdminAccess = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey || apiKey !== process.env.ADMIN_API_KEY) {
    return res.status(403).json({ success: false, message: 'Acc√®s non autoris√©' });
  }
  
  next();
};

// ============ ROUTES D'AUTHENTIFICATION (JWT) ============
const { router: authRouter, authenticateJWT } = require('./routes/authRoutes');
app.use('/api/auth', authRouter);

// ============ ROUTES DES INVIT√âS ============
const guestRouter = require('./routes/guestRoutes');
app.use('/api/guests', guestRouter);

// ============ ENDPOINT HEALTH CHECK ============
app.get('/api/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'invitation-anniversaire',
    version: '1.0.0'
  });
});

// ============ ROUTES ADMINISTRATION ============
// Route pour r√©cup√©rer tous les invit√©s (prot√©g√©e)
app.get('/api/guests', verifyAdminAccess, async (req, res) => {
  try {
    const guests = await RSVP.find().sort({ createdAt: -1 });
    res.status(200).json({ success: true, guests });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des invit√©s:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Route pour ajouter un invit√© (prot√©g√©e)
app.post('/api/guests', verifyAdminAccess, async (req, res) => {
  try {
    const { name, email, personalWelcomeMessage } = req.body;
    
    // Valider les donn√©es
    if (!name || !email) {
      return res.status(400).json({
        success: false,
        message: 'Nom et email requis'
      });
    }
    
    // V√©rifier si l'email existe d√©j√†
    const existingRSVP = await RSVP.findOne({ email });
    if (existingRSVP) {
      return res.status(400).json({
        success: false,
        message: 'Un invit√© avec cet email existe d√©j√†'
      });
    }
    
    // Cr√©er le nouvel invit√©
    const newRSVP = new RSVP({
      name,
      email,
      attending: 'pending', // Status initial
      message: personalWelcomeMessage
    });
    
    await newRSVP.save();
    
    res.status(201).json({
      success: true,
      message: 'Invit√© ajout√© avec succ√®s',
      _id: newRSVP._id,
      name: newRSVP.name,
      email: newRSVP.email
    });
  } catch (error) {
    console.error('Erreur lors de l\'ajout d\'un invit√©:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Route pour supprimer un invit√© (prot√©g√©e)
app.delete('/api/guests/:id', verifyAdminAccess, async (req, res) => {
  try {
    const { id } = req.params;
    
    const deletedRSVP = await RSVP.findByIdAndDelete(id);
    
    if (!deletedRSVP) {
      return res.status(404).json({
        success: false,
        message: 'Invit√© non trouv√©'
      });
    }
    
    res.status(200).json({
      success: true,
      message: 'Invit√© supprim√© avec succ√®s'
    });
  } catch (error) {
    console.error('Erreur lors de la suppression d\'un invit√©:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Route pour les statistiques des invit√©s (prot√©g√©e)
app.get('/api/guests/stats', verifyAdminAccess, async (req, res) => {
  try {
    // Nombre total d'invit√©s
    const totalGuests = await RSVP.countDocuments();
    
    // Nombre d'invit√©s ayant r√©pondu
    const respondedGuests = await RSVP.countDocuments({ attending: { $ne: null } });
    
    // Nombre d'invit√©s confirm√©s pr√©sents
    const attendingGuests = await RSVP.countDocuments({ attending: 'yes' });
    
    // Nombre d'invit√©s ayant d√©clin√©
    const declinedGuests = await RSVP.countDocuments({ attending: 'no' });
    
    // Nombre total de personnes (invit√©s + accompagnants)
    const guestsWithExtras = await RSVP.find({ attending: 'yes' });
    const totalAttendees = guestsWithExtras.reduce((sum, guest) => sum + (guest.guests || 0) + 1, 0);
    
    // Nombre de personnes ayant besoin d'h√©bergement
    const accommodationNeeded = await RSVP.countDocuments({ 
      attending: 'yes', 
      needsAccommodation: true 
    });
    
    // R√©ponse avec statistiques
    res.status(200).json({
      success: true,
      stats: {
        totalGuests,
        respondedGuests,
        attendingGuests,
        declinedGuests,
        totalAttendees,
        accommodationNeeded,
        responseRate: totalGuests > 0 ? Math.round((respondedGuests / totalGuests) * 100) : 0,
        confirmationRate: respondedGuests > 0 ? Math.round((attendingGuests / respondedGuests) * 100) : 0
      }
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des statistiques:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Route pour r√©cup√©rer la liste des invit√©s (prot√©g√©e)
app.get('/api/guests/list', verifyAdminAccess, async (req, res) => {
  try {
    const guests = await RSVP.find().sort({ createdAt: -1 });
    
    res.status(200).json({
      success: true,
      guests: guests.map(guest => ({
        _id: guest._id,
        name: guest.name,
        email: guest.email,
        attending: guest.attending,
        guests: guest.guests,
        needsAccommodation: guest.needsAccommodation,
        message: guest.message,
        createdAt: guest.createdAt
      }))
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des invit√©s:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// ============ ROUTES G√âN√âRATION QR CODES ============
app.post('/api/guests/generate-guest-list', verifyAdminAccess, async (req, res) => {
  try {
    console.log('Route /api/guests/generate-guest-list appel√©e');
    const { guests } = req.body;
    
    // Validation de la liste d'invit√©s
    if (!guests || !Array.isArray(guests)) {
      return res.status(400).json({ success: false, message: 'Liste d\'invit√©s invalide' });
    }
    
    console.log(`Traitement de ${guests.length} invit√©s...`);
    
    // Cr√©ation des dossiers pour les QR codes si n√©cessaire
    const publicQrDir = path.join(__dirname, 'public/qr-codes');
    
    try {
      await fsPromises.mkdir(publicQrDir, { recursive: true });
      console.log('Dossier QR codes cr√©√© ou existant:', publicQrDir);
    } catch (err) {
      console.error('Erreur lors de la cr√©ation du dossier QR codes:', err);
    }
    
    // Traitement des invit√©s et g√©n√©ration des QR codes
    const processedGuests = [];
    const errors = [];
    
    for (const guest of guests) {
      try {
        // Chercher l'invit√© dans la base de donn√©es
        let dbGuest = await RSVP.findOne({ email: guest.email });
        
        if (!dbGuest) {
          // Si l'invit√© n'existe pas, le cr√©er
          dbGuest = new RSVP({
            name: guest.name,
            email: guest.email,
            attending: 'pending',
            message: guest.message || `Bienvenue ${guest.name} ! Nous sommes ravis de vous compter parmi nous.`
          });
          await dbGuest.save();
          console.log(`Nouvel invit√© cr√©√©: ${guest.name} (${guest.email})`);
        }
        
        // G√©n√©rer un identifiant unique cryptographiquement s√©curis√© pour le QR code
        const uniqueId = crypto.randomBytes(16).toString('hex');
        
        // URL √† encoder dans le QR code avec le code unique
        const invitationUrl = `${process.env.BASE_URL || req.protocol + '://' + req.get('host')}/?code=${uniqueId}`;
        
        // Chemin du fichier QR code
        const qrFilename = `${uniqueId}.png`;
        const qrPath = path.join(publicQrDir, qrFilename);
        
        // G√©n√©rer le QR code
        await QRCode.toFile(qrPath, invitationUrl, {
          color: {
            dark: '#E4A11B',  // Ambre
            light: '#FFFFFF'  // Blanc
          },
          width: 500,
          margin: 1,
          errorCorrectionLevel: 'M'
        });
        
        // URL publique du QR code
        const qrCodeUrl = `/qr-codes/${qrFilename}`;
        
        // V√©rifier l'unicit√© du code avant sauvegarde
        let isUnique = false;
        let attempts = 0;
        while (!isUnique && attempts < 5) {
          const existingGuest = await RSVP.findOne({ uniqueCode: uniqueId });
          if (!existingGuest) {
            isUnique = true;
          } else {
            uniqueId = crypto.randomBytes(16).toString('hex');
            attempts++;
          }
        }
        
        if (!isUnique) {
          throw new Error('Impossible de g√©n√©rer un code unique');
        }

        // Mettre √† jour l'invit√© avec l'URL du QR code et le code unique
        dbGuest.qrCodeUrl = qrCodeUrl;
        dbGuest.uniqueCode = uniqueId;
        await dbGuest.save();
        
        // Ajouter √† la liste des invit√©s trait√©s
        processedGuests.push({
          _id: dbGuest._id,
          name: dbGuest.name,
          email: dbGuest.email,
          attending: dbGuest.attending,
          message: dbGuest.message,
          qrCodeUrl: dbGuest.qrCodeUrl
        });
        
        console.log(`QR code g√©n√©r√© pour: ${guest.name} (${guest.email})`);
      } catch (error) {
        console.error(`Erreur pour l'invit√© ${guest.email}:`, error);
        errors.push({
          email: guest.email,
          name: guest.name,
          error: error.message
        });
      }
    }
    
    res.status(200).json({
      success: true,
      message: `${processedGuests.length} QR codes g√©n√©r√©s avec succ√®s`,
      guests: processedGuests,
      errors: errors.length > 0 ? errors : undefined
    });
  } catch (error) {
    console.error('Erreur g√©n√©rale lors de la g√©n√©ration des QR codes:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur: ' + error.message });
  }
});

// ============ ROUTES INVIT√âS ============
// Route pour v√©rifier un code QR et r√©cup√©rer les donn√©es de l'invit√©
app.get('/api/guests/verify/:code', async (req, res) => {
  try {
    const { code } = req.params;
    
    if (!code) {
      return res.status(400).json({ 
        success: false, 
        message: 'Code QR manquant' 
      });
    }
    
    // Chercher l'invit√© avec ce code unique
    const guest = await RSVP.findOne({ uniqueCode: code });
    
    if (!guest) {
      return res.status(404).json({ 
        success: false, 
        message: 'Code QR invalide ou expir√©' 
      });
    }
    
    // Retourner les donn√©es de l'invit√©
    res.status(200).json({
      success: true,
      guest: {
        name: guest.name,
        email: guest.email,
        attending: guest.attending,
        guests: guest.guests,
        message: guest.message,
        needsAccommodation: guest.needsAccommodation,
        hasCheckedIn: guest.hasCheckedIn,
        personalWelcomeMessage: guest.message || `Bienvenue ${guest.name} ! Nous sommes ravis de vous compter parmi nous.`
      }
    });
  } catch (error) {
    console.error('Erreur lors de la v√©rification du code QR:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erreur serveur lors de la v√©rification' 
    });
  }
});

// Routes pour le RSVP
app.post('/api/rsvp', async (req, res) => {
  try {
    const { name, email, attending, guests, message, needsAccommodation } = req.body;
    
    // V√©rifier si l'utilisateur a d√©j√† r√©pondu
    const existingRSVP = await RSVP.findOne({ email });
    
    if (existingRSVP) {
      // Mettre √† jour la r√©ponse existante
      existingRSVP.name = name;
      existingRSVP.attending = attending;
      existingRSVP.guests = guests;
      existingRSVP.message = message;
      existingRSVP.needsAccommodation = needsAccommodation;
      await existingRSVP.save();
      
      return res.status(200).json({ 
        success: true, 
        message: 'Votre r√©ponse a √©t√© mise √† jour',
        locationAccess: attending === 'yes'
      });
    }
    
    // Cr√©er une nouvelle r√©ponse
    const newRSVP = new RSVP({
      name,
      email,
      attending,
      guests,
      message,
      needsAccommodation
    });
    
    await newRSVP.save();
    
    res.status(201).json({ 
      success: true, 
      message: 'Merci pour votre r√©ponse',
      locationAccess: attending === 'yes'
    });
  } catch (error) {
    console.error('Erreur lors du traitement du RSVP:', error);
    res.status(500).json({ success: false, message: 'Erreur lors du traitement de votre r√©ponse' });
  }
});

// Route pour r√©cup√©rer les d√©tails du lieu (uniquement pour ceux qui ont accept√©)
app.get('/api/event-details', async (req, res) => {
  try {
    const { email } = req.query;
    
    if (!email) {
      return res.status(400).json({ success: false, message: 'Email requis' });
    }
    
    const rsvp = await RSVP.findOne({ email });
    
    if (!rsvp) {
      return res.status(404).json({ success: false, message: 'Aucune r√©ponse trouv√©e pour cet email' });
    }
    
    if (rsvp.attending !== 'yes') {
      return res.status(403).json({ success: false, message: 'Acc√®s non autoris√©' });
    }
    
    // D√©tails de l'√©v√©nement pour les invit√©s qui ont accept√©
    const eventDetails = {
      location: {
        name: "Villa Paradise",
        address: "18 Rue du Stade, 17000 La Rochelle, France",
        coordinates: { lat: 46.1603986, lng: -1.1770363 },
        accessCode: "1234", // Code d'acc√®s √† la r√©sidence
        parkingInfo: "Parking priv√© disponible sur place, code portail: 5678"
      },
      accommodationInfo: {
        checkIn: "Vendredi 15 Juin √† partir de 14h",
        checkOut: "Dimanche 17 Juin avant 12h",
        amenities: [
          "Piscine chauff√©e",
          "5 chambres avec salle de bain",
          "Grande terrasse avec vue sur la mer",
          "Cuisine √©quip√©e",
          "Barbecue et plancha"
        ]
      },
      additionalInfo: "N'h√©sitez pas √† apporter maillot de bain et serviette. Des activit√©s sont pr√©vues tout au long du weekend."
    };
    
    res.status(200).json({ success: true, eventDetails });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des d√©tails de l\'√©v√©nement:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Routes pour les photos
app.post('/api/photos', upload.single('photo'), async (req, res) => {
  try {
    if (!storage) {
      return res.status(503).json({ 
        success: false, 
        message: 'Service de photos non disponible - Firebase non configur√©' 
      });
    }

    if (!req.file) {
      return res.status(400).json({ success: false, message: 'Aucune photo t√©l√©charg√©e' });
    }
    
    const { name } = req.body;
    
    // G√©n√©rer un nom de fichier unique
    const timestamp = Date.now();
    const filename = `photos/${timestamp}_${req.file.originalname}`;
    
    // R√©f√©rence au fichier dans Firebase Storage
    const storageRef = ref(storage, filename);
    
    // T√©l√©charger le fichier
    await uploadBytes(storageRef, req.file.buffer, {
      contentType: req.file.mimetype
    });
    
    // Obtenir l'URL de t√©l√©chargement
    const photoUrl = await getDownloadURL(storageRef);
    
    // Cr√©er une entr√©e dans la base de donn√©es
    const newPhoto = new Photo({
      url: photoUrl,
      uploadedBy: name || 'Invit√© anonyme'
    });
    
    await newPhoto.save();
    
    res.status(201).json({ success: true, photo: newPhoto });
  } catch (error) {
    console.error('Erreur lors du t√©l√©chargement de la photo:', error);
    res.status(500).json({ success: false, message: 'Erreur lors du t√©l√©chargement de la photo' });
  }
});

// R√©cup√©rer toutes les photos
app.get('/api/photos', async (req, res) => {
  try {
    const photos = await Photo.find().sort({ createdAt: -1 });
    res.status(200).json({ success: true, photos });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des photos:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Route pour t√©l√©charger tous les QR codes
app.get('/api/guests/download-qr-codes', authenticateJWT, async (req, res) => {
  try {
    console.log('Route /api/guests/download-qr-codes appel√©e');
    
    // R√©cup√©rer tous les invit√©s avec des QR codes
    const guests = await RSVP.find({ qrCodeUrl: { $exists: true, $ne: null } });
    
    if (guests.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aucun QR code trouv√©. Veuillez d\'abord g√©n√©rer les QR codes.'
      });
    }
    
    console.log(`Pr√©paration de ${guests.length} QR codes pour t√©l√©chargement...`);
    
    // D√©finir les en-t√™tes pour le t√©l√©chargement
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', 'attachment; filename=qr-codes-invites.zip');
    
    // Cr√©er un stream d'archive
    const archive = archiver('zip', {
      zlib: { level: 9 } // Niveau de compression maximal
    });
    
    // G√©rer les erreurs d'archivage
    archive.on('error', (err) => {
      console.error('Erreur d\'archivage:', err);
      res.status(500).end();
    });
    
    // Connecter l'archive au response
    archive.pipe(res);
    
    // Ajouter chaque QR code √† l'archive
    const baseDir = path.join(__dirname, 'public');
    
    for (const guest of guests) {
      if (!guest.qrCodeUrl) continue;
      
      try {
        // Chemin absolu du QR code
        const qrPath = path.join(baseDir, guest.qrCodeUrl.replace(/^\//, ''));
        
        // V√©rifier si le fichier existe
        try {
          await fsPromises.access(qrPath);
        } catch (err) {
          console.warn(`QR code introuvable pour ${guest.name} (${guest.email}): ${qrPath}`);
          continue;
        }
        
        // Nom de fichier normalis√© pour l'archive
        const sanitizedName = guest.name
          .replace(/[^\w\s-]/g, '') // Supprimer les caract√®res sp√©ciaux
          .replace(/\s+/g, '_');    // Remplacer les espaces par des underscores
        
        const filename = `${sanitizedName}_${guest.email.split('@')[0]}.png`;
        
        // Ajouter le fichier √† l'archive
        archive.file(qrPath, { name: filename });
        console.log(`QR code ajout√© √† l'archive: ${filename}`);
      } catch (fileError) {
        console.error(`Erreur lors de l'ajout du QR code pour ${guest.name}:`, fileError);
        // Continuer avec les autres QR codes
      }
    }
    
    // Finaliser l'archive
    await archive.finalize();
    console.log('Archive ZIP finalis√©e et envoy√©e');
  } catch (error) {
    console.error('Erreur lors du t√©l√©chargement des QR codes:', error);
    // Si la r√©ponse n'a pas encore commenc√©, envoyer une erreur JSON
    if (!res.headersSent) {
      res.status(500).json({ 
        success: false, 
        message: 'Erreur lors de la cr√©ation de l\'archive: ' + error.message 
      });
    } else {
      // Sinon, terminer simplement la r√©ponse
      res.end();
    }
  }
});

// ‚úÖ Fonction corrig√©e pour trouver le chemin client/build
const findClientBuildPath = () => {
  // Options possibles de chemin en fonction de la structure de d√©ploiement
  const possiblePaths = [
    path.join(__dirname, 'client/build'),               // Chemin standard
    path.join(__dirname, '../client/build'),            // Un niveau au-dessus
    path.resolve('/opt/render/project/src/client/build'),// Chemin Render sp√©cifique
    path.resolve('./client/build')                      // Chemin relatif au process
  ];
  
  console.log('üîç Recherche du dossier client/build...');
  console.log('R√©pertoire de travail actuel:', process.cwd());
  console.log('__dirname:', __dirname);
  
  // V√©rifier chaque chemin et retourner le premier valide
  for (const testPath of possiblePaths) {
    try {
      console.log(`   V√©rification: ${testPath}`);
      if (fs.existsSync(testPath)) {
        console.log(`‚úÖ Chemin client/build valide trouv√©: ${testPath}`);
        
        // V√©rifier le contenu du dossier
        try {
          const contents = fs.readdirSync(testPath);
          console.log(`   Contenu (${contents.length} √©l√©ments):`, contents.slice(0, 5).join(', ') + (contents.length > 5 ? '...' : ''));
          
          // V√©rifier si index.html existe
          const indexPath = path.join(testPath, 'index.html');
          if (fs.existsSync(indexPath)) {
            console.log(`‚úÖ index.html trouv√©: ${indexPath}`);
            return testPath;
          } else {
            console.log(`‚ùå index.html manquant dans: ${testPath}`);
          }
        } catch (readError) {
          console.log(`‚ùå Erreur de lecture du dossier ${testPath}:`, readError.message);
        }
      } else {
        console.log(`‚ùå Chemin inexistant: ${testPath}`);
      }
    } catch (err) {
      console.log(`‚ùå Erreur lors de la v√©rification du chemin ${testPath}:`, err.message);
    }
  }
  
  console.error('üö® ATTENTION: Aucun chemin client/build valide trouv√©!');
  return null;
};

// ‚úÖ Servir les fichiers statiques en production avec gestion robuste
if (process.env.NODE_ENV === 'production') {
  console.log('üè≠ Mode production activ√© - Configuration des fichiers statiques...');
  
  // D√©terminer le bon chemin pour les fichiers statiques
  const clientBuildPath = findClientBuildPath();
  
  if (clientBuildPath) {
    // Servir les fichiers statiques
    console.log(`üìÅ Servant les fichiers statiques depuis: ${clientBuildPath}`);
    app.use(express.static(clientBuildPath));
    
    // Servir les QR codes depuis public/qr-codes
    const qrCodesPath = path.join(__dirname, 'public/qr-codes');
    if (fs.existsSync(qrCodesPath)) {
      app.use('/qr-codes', express.static(qrCodesPath));
      console.log(`üìÑ QR codes servis depuis: ${qrCodesPath}`);
    }
    
    // Route catch-all pour React Router (doit √™tre en dernier)
    app.get('*', (req, res, next) => {
      // Ne pas intercepter les routes API
      if (req.path.startsWith('/api/')) {
        return next();
      }
      
      // Chemin vers index.html
      const indexPath = path.join(clientBuildPath, 'index.html');
      
      // V√©rifier si le fichier existe avant de le servir
      try {
        if (fs.existsSync(indexPath)) {
          console.log(`üìÑ Servant index.html pour: ${req.path}`);
          return res.sendFile(indexPath);
        } else {
          console.error(`‚ùå ERREUR: index.html non trouv√© √†: ${indexPath}`);
          return res.status(404).send(`
            <!DOCTYPE html>
            <html>
            <head>
              <title>Erreur 404</title>
              <meta charset="utf-8">
              <meta name="viewport" content="width=device-width, initial-scale=1">
            </head>
            <body>
              <h1>Erreur 404</h1>
              <p>Fichier index.html introuvable √†: ${indexPath}</p>
            </body>
            </html>
          `);
        }
      } catch (err) {
        console.error(`‚ùå Erreur lors de l'acc√®s √† index.html:`, err);
        return res.status(500).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Erreur 500</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
          </head>
          <body>
            <h1>Erreur 500</h1>
            <p>Erreur serveur lors de l'acc√®s au fichier index.html</p>
            <p>D√©tail: ${err.message}</p>
          </body>
          </html>
        `);
      }
    });
  } else {
    // Fallback si aucun chemin valide n'est trouv√©
    console.error('üö® ERREUR CRITIQUE: Impossible de trouver le dossier client/build!');
    
    // Middleware pour informer l'utilisateur
    app.use((req, res, next) => {
      if (!req.path.startsWith('/api/')) {
        return res.status(503).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Service temporairement indisponible</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
              body { 
                font-family: system-ui, -apple-system, sans-serif; 
                text-align: center; 
                padding: 50px; 
                background: linear-gradient(135deg, #fef3c7, #fde68a);
                color: #92400e;
                margin: 0;
              }
              .container { 
                max-width: 600px; 
                margin: 0 auto; 
                background: white; 
                padding: 40px; 
                border-radius: 15px; 
                box-shadow: 0 10px 25px rgba(0,0,0,0.1);
              }
              h1 { color: #d97706; margin-bottom: 20px; }
              .loading { 
                display: inline-block; 
                width: 20px; 
                height: 20px; 
                border: 3px solid #f3f3f3; 
                border-top: 3px solid #d97706; 
                border-radius: 50%; 
                animation: spin 1s linear infinite; 
                margin: 20px 0;
              }
              @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
              .btn {
                background: #d97706; 
                color: white; 
                border: none; 
                padding: 12px 24px; 
                border-radius: 8px; 
                cursor: pointer; 
                font-size: 16px;
                margin: 20px 10px;
                text-decoration: none;
                display: inline-block;
              }
              .btn:hover { background: #b45309; }
              .debug {
                background: #f3f4f6;
                padding: 20px;
                border-radius: 8px;
                margin: 20px 0;
                text-align: left;
                font-family: monospace;
                font-size: 12px;
                color: #374151;
              }
            </style>
          </head>
          <body>
            <div class="container">
              <h1>üéâ Application en cours de d√©ploiement</h1>
              <div class="loading"></div>
              <p><strong>L'application React est en cours de compilation...</strong></p>
              <p>Ceci peut prendre quelques minutes lors du premier d√©ploiement.</p>
              
              <div class="debug">
                <strong>Informations de diagnostic :</strong><br>
                ‚Ä¢ R√©pertoire de travail: ${process.cwd()}<br>
                ‚Ä¢ __dirname: ${__dirname}<br>
                ‚Ä¢ NODE_ENV: ${process.env.NODE_ENV}<br>
                ‚Ä¢ Timestamp: ${new Date().toISOString()}
              </div>
              
              <button onclick="window.location.reload()" class="btn">
                üîÑ Rafra√Æchir la page
              </button>
              
              <a href="/api/health" class="btn" style="background: #059669;">
                ‚úÖ V√©rifier l'API
              </a>
              
              <p style="margin-top: 30px; font-size: 14px; color: #6b7280;">
                Si le probl√®me persiste apr√®s 10 minutes, contactez l'administrateur.
              </p>
            </div>
          </body>
          </html>
        `);
      }
      next();
    });
  }
} else {
  // ‚úÖ En mode d√©veloppement
  console.log('üõ†Ô∏è Mode d√©veloppement - API seulement');
  app.get('/', (req, res) => {
    res.json({
      message: 'API Server is running! üöÄ',
      mode: 'development',
      endpoints: {
        health: '/api/health',
        admin: '/api/auth/admin',
        guests: '/api/guests'
      },
      frontend: 'Should be running on port 3000'
    });
  });
}

// ‚úÖ Gestion globale des erreurs
app.use((err, req, res, next) => {
  console.error('‚ùå Erreur serveur non g√©r√©e:', err.stack);
  
  // Ne pas exposer les d√©tails d'erreur en production
  const errorDetails = process.env.NODE_ENV === 'development' ? {
    message: err.message,
    stack: err.stack
  } : {
    message: 'Une erreur interne est survenue'
  };
  
  res.status(500).json({ 
    success: false, 
    message: 'Erreur interne du serveur',
    error: errorDetails
  });
});

// ‚úÖ Gestion des routes non trouv√©es
app.use('*', (req, res) => {
  if (req.originalUrl.startsWith('/api/')) {
    return res.status(404).json({
      success: false,
      message: `Route API non trouv√©e: ${req.method} ${req.originalUrl}`,
      availableRoutes: [
        'GET /api/health',
        'POST /api/auth/admin',
        'GET /api/guests',
        'POST /api/guests',
        'POST /api/rsvp'
      ]
    });
  }
  
  // Pour les routes non-API en production, cela devrait √™tre g√©r√© par le catch-all React
  res.status(404).send('Route non trouv√©e');
});

// ‚úÖ D√©marrage du serveur avec logs d√©taill√©s
app.listen(PORT, '0.0.0.0', () => {
  console.log('üöÄ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüöÄ');
  console.log(`üéâ Serveur d√©marr√© avec succ√®s sur le port ${PORT}`);
  console.log(`üåç Mode: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üìÅ R√©pertoire de travail: ${process.cwd()}`);
  console.log(`üìÇ R√©pertoire serveur: ${__dirname}`);
  console.log(`‚è∞ D√©marrage: ${new Date().toISOString()}`);
  console.log('üöÄ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüöÄ');
  
  // Routes disponibles
  console.log('üì° Routes API disponibles:');
  console.log(`   üîê Admin: http://localhost:${PORT}/api/auth/admin`);
  console.log(`   ‚ù§Ô∏è  Health: http://localhost:${PORT}/api/health`);
  console.log(`   üë• Invit√©s: http://localhost:${PORT}/api/guests`);
  console.log(`   üìù RSVP: http://localhost:${PORT}/api/rsvp`);
  
  if (process.env.NODE_ENV === 'production') {
    console.log(`   üåê Frontend: http://localhost:${PORT}/`);
  } else {
    console.log(`   üõ†Ô∏è  Frontend dev: http://localhost:3000/`);
  }
  console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
});